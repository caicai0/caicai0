{"meta":{"title":"caicai0.github.io","subtitle":null,"description":null,"author":"liyufeng","url":"https://caicai0.github.io"},"pages":[],"posts":[{"title":"iOS利用Contacts.framework导入表格通讯录","slug":"iOS利用Contacts-framework导入表格通讯录","date":"2017-02-21T05:33:11.000Z","updated":"2017-02-21T05:37:20.000Z","comments":true,"path":"2017/02/21/iOS利用Contacts-framework导入表格通讯录/","link":"","permalink":"https://caicai0.github.io/2017/02/21/iOS利用Contacts-framework导入表格通讯录/","excerpt":"","text":"#故事背景公司有有个excel文件保存更新公司成员的通讯信息。每次修改都不知道改了哪里，而且手工一个一个往通讯录里面添加，两个就没有耐心了。因为有时候这些信息还真的会用到，为了用的时候不抓瞎，只能想办法导入到通讯录。 #过程公司通讯录结构还是很复杂的，有姓名、电话、手机、邮箱、部门、职位。幸好这些在iphone系统通讯录里面都可以有。这个时候问题来了excel文件ios不知道怎么处理？我的处理办法是，首先把字段安排好。姓名、手机、邮箱、部门、职位。然后导出csv，这样就成了纯文本文件了。（我这里还做了一件事，打开csv。1.把没有用的空格去掉、2.把不和谐的换行和引号去掉了、3.重新保存成unicode编码的文件txl.csv）然后其实就没有什么了，直接开始上代码 func func3() -&gt; () { let path = Bundle.main.path(forResource: &quot;txl&quot;, ofType: &quot;csv&quot;) do { let string = try String(contentsOfFile: path!) let lines = string.components(separatedBy: &quot;\\n&quot;) let request = CNSaveRequest() var lastDepartment = &quot;&quot;; for line in lines { var labels = line.components(separatedBy: &quot;,&quot;); let name = labels[0] let phone = labels[1] let email = labels[2] let department : String = labels[3] let title = labels[4] let lastName = name.substring(to: name.index(name.startIndex, offsetBy: 1)) let givenName = name.substring(from: name.index(name.startIndex, offsetBy:1)) let contact = CNMutableContact() contact.givenName = givenName contact.familyName = lastName let phonenumber = CNLabeledValue(label: CNLabelPhoneNumberMobile, value: CNPhoneNumber(stringValue: phone)) contact.phoneNumbers = [phonenumber] let workEmail = CNLabeledValue(label: CNLabelWork, value: email as NSString) contact.emailAddresses = [workEmail] contact.organizationName = &quot;公司名称&quot; if department != &quot;&quot; { contact.departmentName = department; lastDepartment = department; }else{ contact.departmentName = lastDepartment; } contact.jobTitle = title; request.add(contact, toContainerWithIdentifier: nil) } let store = CNContactStore() do { try store.execute(request) } catch let e { print(e) } } catch let e { print(e) } } 导入到手机了。还是不行，因为我们是机械的新建联系人，致使现在通讯录里面的联系人出现了重复的现象。这个功能其实用代码规避一下也是可以的，但是我还是比较懒的。我下载了一个QQ同步助手，在这个app里面的通讯录管理里面有一个合并联系人。app可以自动合并一部分，自动合并不了的会提示手动合并。到此处才算是圆满结束。 #源码iOS利用Contacts.framework导入表格通讯录——Demo","categories":[],"tags":[{"name":"ios,contacts.framework,excel,通讯录","slug":"ios-contacts-framework-excel-通讯录","permalink":"https://caicai0.github.io/tags/ios-contacts-framework-excel-通讯录/"}]},{"title":"树莓派保持网络连接shell脚本","slug":"树莓派保持网络连接shell脚本","date":"2017-02-13T01:20:06.000Z","updated":"2017-02-17T06:19:09.000Z","comments":true,"path":"2017/02/13/树莓派保持网络连接shell脚本/","link":"","permalink":"https://caicai0.github.io/2017/02/13/树莓派保持网络连接shell脚本/","excerpt":"","text":"#树莓派保持网络连接shell脚本 ##故事背景 树莓派3b现在有了板载无线网卡，可以很方便的连接到wifi。但是无线路由器不能保证永远正常工作，由于各种原因会重启路由。这个时候，raspberry3b就会有一定概率断开网络连接。系统级功能比如像手机一样有网就连，断网后自动重连的功能目前没有能力实现。所以就想搞一个脚本检查网络连接状态，如果没有网络重启一下。 ##shell脚本 #! /bin/bash #检测网络连接 log=/root/network.log #判断输出日志文件是否存在 if [ ! -f ${log} ] then touch ${log} fi ping -c 1 192.168.1.1 &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ];then #echo `date` 检测网络正常 &gt;&gt; ${log} else echo `date` 检测网络异常 &gt;&gt; ${log} reboot fi 这个脚本基本上是ping路由地址（192.168.1.1）来判断无线的连接状态，$?是上一条命令执行的return值。ping通返回0，ping不通返回不是0。当ping不通的时候写下日志，然后重启系统（为什么不重启网络？我是真的不在家的时间有点长，所以没有胆量尝试）。 ##定时运行 起初想用nodejs脚本定时运行，自己都觉得小题大作了。转而寻找用shell脚本实现的思路。查资料后发现linux系统本身有一个cron服务（俗称定时任务）。修改/etc/crontab文件，添加一行 */5 * * * * root bash /root/network.sh 当系统时间的分钟整除5的时候就会以root身份调用一个后面的bash /root/network.sh命令。","categories":[],"tags":[{"name":"raspberry,树莓派,shell,network","slug":"raspberry-树莓派-shell-network","permalink":"https://caicai0.github.io/tags/raspberry-树莓派-shell-network/"}]}]}